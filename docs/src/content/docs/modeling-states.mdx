---
title: Modeling States
description: Overview of the recommended methods to design the states when using bloc.
---

The following approaches are simply recommendations and are completely optional.
Feel free to use whatever method to model your state that you prefer.
You may find some of the examples/documentation do not follow the approaches mainly for simplicity/conciseness.

:::note
Bloc Library imposes no restrictions on the approach or method used to design state classes.
:::

When designing state classes for the BLoC library,
there are several approaches you can take. Each has its own advantages and drawbacks. 
Here’s a simple guide to help understand these approaches, their pros and cons, and when to use each one.

:::tip
The following code examples are focused on the state design, you might also want to:
- Use `Equatable` from [equatable](https://pub.dev/packages/equatable) package or `@Data()` from [data_class](https://pub.dev/packages/data_class).
- Implement the `copyWith` method.
- Mark the class as **immutable** with `@immutable` from [meta](https://pub.dev/packages/meta). Use the `const` keyword for constructors.
:::

## 1. Single Data Class with Status Enum

**Overview:**

In this approach, you have a **single class** for all states and use an enum to represent different statuses.
Properties are made nullable and you handle them based on the current status.

```dart
enum TodoStatus { initial, loading, success, failure }
final class TodoState {
  const TodoState({this.status = TodoStatus.initial, this.exception = null});
  final TodoStatus status;
  /// Accessible in case of failure
  final Exception? exception;
}
```

**Pros:**

- **Simplicity**: Easier to manage a single class and a status enum.
- **Shared Properties**: All states share the same properties without duplication in the same class.

**Cons:**

- **Error-Prone:** You have to check the state status before accessing properties, It's possible to **emit
a state** without passing the required properties for a specific status which can lead to bugs. Can be solved by writing tests.
- **Nullable Properties:** Properties for specific states are nullable, which can be cumbersome to manage.

**When to Use**:

This approach is useful for simpler cases where the states don’t have many unique properties, 
and you prefer to manage state changes with a status enum. It can also work for more advanced use cases.

## 2. Sealed Class with Subclasses

**Overview:**

This approach is great for separate exclusive states, you have a **sealed class** that has the shared properties, 
and then extend it with specific subclasses for different states in the same file.

Each state can have its own properties.

```dart
sealed class TodoState {}
final class TodoInitial extends TodoState {}
final class TodoLoadInProgress extends TodoState {}
final class TodoLoadSuccess extends TodoState {}
final class TodoLoadFailure extends TodoState {
  TodoLoadFailure({required this.exception});

  final Exception exception;
}
```

**Pros:**

- **Type Safety**: Each subclass can have its own properties, making it clear which properties belong to which state. You can
exhaustiveness checks the state by using the `when` statement. 
If you don't want [exhaustive switching](https://dart.dev/language/branches#exhaustiveness-checking)
or want to be able to add subtypes later without breaking the API (in case this is a library), use the [final](https://dart.dev/language/class-modifiers#final) 
modifier. See the [Sealed Class Docs](https://dart.dev/language/class-modifiers#sealed) for more details.
- **Encapsulation**: You can encapsulate shared properties in the base class and extend it for specific state needs.

**Cons:**

- **Duplication**: You may end up duplicating code for shared properties across subclasses in case you want to retain the shared properties
on each time when emitting a subclass, since you will have to require the properties on each subclass and pass it to the sealed class.
This means it's required to read the shared properties in the **Cubit/Bloc**, and pass them when creating a new state.
- **Maintenance**: Adding new properties requires updating each subclass and the base class, which can be cumbersome.

**When to Use**:

Choose this approach if you have well-defined states with 
unique properties and want to maintain type safety for each state.

## 3. A mix of Both: Data Class with Status Sealed Class

**Overview:**

This approach combines a main **data class** with a `sealed class` for different states.
The main class holds **shared properties**, and the `sealed class` represents different states.

This approach is great for states that are not exclusive.

```dart
final class UpdaterState {
  UpdaterState({
    this.status = const UpdaterIdle(),
    this.updateAvailable = false,
    this.isNewPatchReadyToInstall = false,
  });

  final UpdaterStatus status;
  final bool updateAvailable;
  final bool isNewPatchReadyToInstall;
}

sealed class UpdaterStatus {
  UpdaterStatus();
}

final class UpdaterIdle extends UpdaterStatus {
  UpdaterIdle();
}

final class UpdaterUpdateCheckInProgress extends UpdaterStatus {
  UpdaterUpdateCheckInProgress();
}

final class UpdaterDownloadInProgress extends UpdaterStatus {
  UpdaterDownloadInProgress({
    required this.downloadedProgress,
    required this.downloadedBytes,
    required this.bytesToDownload,
  });

  final double downloadedProgress;
  final double downloadedBytes;
  final double bytesToDownload;
}
```

**Pros:**

- **Type Safety:** Ensures type safety while handling specific state data.
- **Clear Structure:** Separates shared properties from state-specific properties.

**Cons:**

- **Complexity:** This approach might be a bit more complex and might require more design consideration.
Also, this approach might not be suitable in case you don't want to retain the value of the shared properties.
- **Naming Issues**: The term status might not always clearly represent the different states.

**When to Use:**

Opt for this approach if you need a balance of type safety and clear state management,
especially in more complex scenarios.